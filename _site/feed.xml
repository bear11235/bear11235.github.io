<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-20T19:29:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">bear11235’s blog</title><subtitle>bear11235&apos;s study blog. </subtitle><author><name>bear11235</name></author><entry><title type="html">Kernel method 공부하기</title><link href="http://localhost:4000/study/machine%20learning/kernel-method/" rel="alternate" type="text/html" title="Kernel method 공부하기" /><published>2023-04-20T00:00:00+09:00</published><updated>2023-04-20T00:00:00+09:00</updated><id>http://localhost:4000/study/machine%20learning/kernel-method</id><content type="html" xml:base="http://localhost:4000/study/machine%20learning/kernel-method/"><![CDATA[<h1 id="linear-regression-with-non-linear-features">Linear Regression with Non-linear Features</h1>

<p>어떤 데이터 x를 다루고 싶을 때, 그 x를 그대로 모델의 입력값으로 사용할 수도 있지만, 어떤 \(y=f(x)\)라는 매핑을 통해 일차적으로 변환을 하고, 그 이후에 모델에 집어넣을 수 있다. 예를 들어 x를 n차 다항식 형태로 매핑을 한다고 생각해보자.</p>

\[y = w_0x_0 + \cdots w_nx_n = [w_0, \cdots, w_n]^T \cdot [x^0, \cdots, x^n] = \mathbf{w \cdots x}\]

<p>linear regression에서 선형성은 파라미터 \(w\)에 대한 선형성이다. \(x\)는 다항함수를 지나기 때문에 선형성이 유지되진 않지만, 모델은 \(w_i\)에 대해 1차로 구성되어 있기 때문에 파라미터에 대한 선형성을 가지고 있다. 이때 어떤 변환을 거쳐야 하는지는 데이터의 특성과 밀접한 관련이 있다.</p>
<ul>
  <li>주기적인 데이터를 가진 경우는 \(sin / cos\) 등과 같은 harmonic function 등을 사용할 수 있다.</li>
  <li>고차항이 필요하다면 다음의 변환을 생각해볼 수 있다.</li>
</ul>

\[\phi(x) = [1, x, x^2, \cdots ]\]

<ul>
  <li>변수 사이의 상관 관계가 있다면 다음 변환</li>
</ul>

\[\phi(x) = [1, x_{1}x_{2}, x_{3}x_{4}, \cdots]\]

<p>이 방법에서 핵심은 non-linear feature + linear model이라는 것. 즉 변수는 비선형 변환을 통해 복잡한 패턴을 잡아낼 수 있지만 모델 자체는 선형이기 때문에 다루기 쉽다. 위에 예시에서 보듯 보통 feature를 생성할 때는 원래 데이터보다 더 고차원의 공간으로 매핑을 하게 된다. 이는 데이터를 다룰 때 계산량을 키우게 되는 단점을 가지고 있다. 이를 보안하기 위해 <strong>kernel method</strong>를 생각하게 되었다.</p>

<h1 id="kernel">Kernel</h1>

<h2 id="kernel-method">kernel method</h2>

<p>위 예시에서 나타난 공통점인데, input x는 feature로의 변환을 거치고, 그 변환된 feature들은 모델의 파라미터와 dot product를 하게 된다. kernel method는 중간 단계인 x-&gt;y로의 feature 변환을 건너 뛰려는 목적을 가지고 있다. 이를 <strong>kernel trick</strong>이라고 부른다. 이 커널 트릭을 통해 고차원으로의 변환을 찾거나 계산할 필요 없이, 바로 저차원의 데이터를 가지고 계산하면 된다. 쉽게 말해서 고차원의 데이터가 등장하는 중간 단계를 건너 뛰고 똑같은 계산 결과를 얻는 과정이다.</p>

<p>다음의 예시를 보자. 2차원 데이터 x,y에 대해 2nd order polynomial kernel \(k(x,y)=(x \cdot y)^2\)를 생각해보자. 커널 계산 결과는 다음과 같다. 우리는 2차원 데이터 x,y 만을 가지고 계산했지만 사실 그 과정에는 3차원으로의 매핑 -&gt; 내적 이라는 계산 과정이 들어간 것이다.</p>

\[k(x,y)=(x \cdot y)^2=(x_1 y_1 + x_2 y_2)^2 = (x_1^2, x_2^2, \sqrt{2} x_1 x_2) \cdot (y_1^2, y_2^2, \sqrt{2} y_1 y_2)\]

<h2 id="kernel-examples">kernel examples</h2>
<ul>
  <li>Linear Kernel: \(k(x,y) = x \cdot y\)</li>
  <li>Polynomial kernel: \(k(x,y) = (x \cdot y)^d or (x \cdot y + 1)^d\)</li>
  <li>Gaussian of RBF kernel: \(k(x,y) = \exp{(\frac{\vert x-y \vert}{2l^2})}\)</li>
</ul>

<h2 id="kernel-properties">kernel properties</h2>
<p>커널을 통해 feature transformation 계산을 하지 않아도 되는 것은 알겠는데, 그렇다면 특성으로의 변환과 커널 함수는 서로 일대일 대응이 되는지 궁금해진다. 즉 임의의 feature로의 변환을 생각했을 때 그에 대응되는 커널 함수 k가 있는지, 그리고 임의의 커널함수 k를 생각했을 때 그에 대응되는 feature가 있는지 말이다.</p>

<p>커널이 다음의 두 조건을 만족하면, 그에 대응되는 유일한 feature가 존재한다고 한다. 근데 실제로는 PSD가 아닌 커널 함수여도 충분히 유용한 커널 함수가 존재한다더라.</p>
<ul>
  <li>symmetric</li>
  <li>positive semi-definite (PSD)</li>
</ul>

<p>kernel은 다음과 같이 normalized 될 수 있다.</p>

<h1 id="algorithms-using-kernel">Algorithms Using Kernel</h1>
<p>선형 모델을 생각해보면 \(\mathbf{w^T x}\) 항이 등장한다. 이는 weight vector가 data와 같은 공간에 위치하는 것을 의미한다(중요).</p>

<h2 id="kernel-perceptron-algorithm">Kernel Perceptron Algorithm</h2>
<p>perceptron은 x를 인풋으로 받아 그 값을 +1/-1로 구분하는 단순한 모델. 
이것을 풀다보면 \(\mathbf{x \cdot x}\) 가 등장하는데, 이 항을 커널 함수로 바꾸는 알고리즘.
여기서 학습은 계수값인 \(\alpha\)를 업데이트 하는 것.</p>

<h2 id="kernel-linear-regression">Kernel Linear Regression</h2>
<p>Regression model에서 Ordinary Least Square(OLS)는 오차의 제곱을 최소로 하도록 하는 것.</p>

<p>Kernelization</p>

<p>우리가 찾고자 하는 solution of weight vector를 데이터 포인트의 linear combination으로 표현해보자.</p>

<p>\(\mathbf{w}=\sum_{i=1}{n}\alpha_i\mathbf{x_i}=\mathbf{X}\vec{\alpha}\)
\(\mathbf{w}=\mathbf{(XX^T)^{-1}Xy}\)</p>

<p>당연히 아직은 alpha값은 모르며, 학습을 통해 alpha를 업데이트 해갈 것이다. 가중치를 찾는 것은 alpha를 찾는 것과 동일. 위처럼 표현한 가중치 벡터에 데이터를 곱하면 아래와 같다.</p>

\[\mathbf{w^T z}=\sum_{i=1}{n}\alpha_i\mathbf{x_i^T z}\]

<p>위 식에서 \(\mathbf{x^T z}=k(\mathbf{x}, \mathbf{z})\)로 kernelize 할 수 있다. 그렇게 되면 아래 같이 정리된다.</p>

\[\vec{\alpha} = \mathbf{K^{-1}y}\]

<p>Ridge regression은 위와 유사한다.</p>

<p>*유사도라는 개념. w를 x의 선형 결합으로 표현한다는 것은 데이터 사이의 유사도 개념과 밀접하다. perceptron 예시 참고.</p>

<h2 id="kernel-pca">Kernel PCA</h2>]]></content><author><name>bear11235</name></author><category term="study" /><category term="machine learning" /><category term="study" /><category term="machine learning" /><category term="kernel" /><summary type="html"><![CDATA[Linear Regression with Non-linear Features]]></summary></entry><entry><title type="html">EM 알고리즘 공부하기</title><link href="http://localhost:4000/study/machine%20learning/expectation-maximization/" rel="alternate" type="text/html" title="EM 알고리즘 공부하기" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/study/machine%20learning/expectation-maximization</id><content type="html" xml:base="http://localhost:4000/study/machine%20learning/expectation-maximization/"><![CDATA[]]></content><author><name>bear11235</name></author><category term="study" /><category term="machine learning" /><category term="study" /><category term="machine learning" /><category term="EM" /><category term="GMM" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Undirected model 공부하기</title><link href="http://localhost:4000/study/machine%20learning/undirected-graphical-model/" rel="alternate" type="text/html" title="Undirected model 공부하기" /><published>2023-04-18T00:00:00+09:00</published><updated>2023-04-18T00:00:00+09:00</updated><id>http://localhost:4000/study/machine%20learning/undirected-graphical-model</id><content type="html" xml:base="http://localhost:4000/study/machine%20learning/undirected-graphical-model/"><![CDATA[<h1 id="directed-vs-undirected">Directed vs Undirected</h1>
<ul>
  <li>적용하고자 하는 application에서 변수 간 order가 있을 수도 있고 없을 수도 있음.</li>
  <li>오늘의 날씨와 내일의 날씨는 order가 있음.</li>
  <li>이미지의 픽셀 정보는 order가 없음.</li>
  <li>순서가 있는 경우에는 DAG 모델을 주로 사용하고, 순서가 없는 경우에는 Undirected Graphical Model(UG, UGM) 혹은 Markov Random Fields(MRF)를 사용한다.</li>
  <li>BN에서는 Conditional Probability Table(CPT)를 사용하여 변수 간 관계를 정했다면, UG에서는 각 변수 노드간 연결이 “얼마나 잘 어울리는가”, “그럴듯한 조합이다”의 정도를 판단한다. (?)</li>
</ul>

<h2 id="ug의-예시">UG의 예시</h2>
<ol>
  <li>Ising Model
    <ul>
      <li>격자 구조를 갖는 분자 구조에서 각 분자의 극성(+/-)은 해당 분자의 주변 분자에서 영향을 갖는다.</li>
      <li>확률이 높은 상태라는 것은 에너지가 낮은 상태라는 것.</li>
    </ul>
  </li>
  <li>이미지 처리
    <ul>
      <li>이미지에서 denoising. noised pixel value는 실제 관측된 값, true pixel value는 관측되지 않은 값이라 생각할 수 있다. noised value를 가지고 denoised value를 확률적으로 추정할 수 있을까?</li>
    </ul>
  </li>
</ol>

<h1 id="ug의-수학적-표현">UG의 수학적 표현</h1>

<h2 id="정의">정의</h2>
<ul>
  <li><strong>Clique</strong>
    <ul>
      <li>어떤 그래프 \(G\)가 주어져 있을 때, 그것의 subgraph 중 complete graph를 의미한다.</li>
      <li>즉 부분 그래프 중 완전그래프를 clique라고 정의.</li>
      <li>노드의 개수가 0개인 경우 또한 clique</li>
      <li>노드의 개수가 1개인 경우 또한 clique</li>
      <li>Maximal Clique: 모든 clique 중에 가장 큰 clique. 가장 크다는 것은 어떤 노드를 추가하더라도 clique이 되지 못하는 경우를 의미.</li>
    </ul>
  </li>
  <li><strong>Potential Function</strong>, \(\psi_c(\mathbf{x}_c)\)
    <ul>
      <li>\(c\)라는 clique 안의 x에 대해 \(\mathbf{x}_c\)가 얼마나 그럴듯한지 (확률이 높은지) 의미하는 함수.</li>
    </ul>
  </li>
  <li><strong>Partition Function</strong>, Z
    <ul>
      <li>Normalize를 위한 상수.</li>
      <li>\(Z = \sum_{x_1, \cdots, x_n} \prod_{c\in C} \psi_c(x_c)\): 모든 clique에 대한 potential function 값을 모두 곱한 뒤, 가능한 모든 x의 경우에 대해 더한다.</li>
    </ul>
  </li>
</ul>

<h2 id="표현">표현</h2>
<ul>
  <li>n개의 노드를 가진 undirected graph, \(H\)를 생각하자. n개 변수들의 확률 분포는 \(P(X_1, \cdots, X_n)\)으로 표현할 수 있다.</li>
  <li>확률 분포는 아래와 같이 potential functions의 곱으로 표현됨. (이처럼 될 수 있다는 정리는 뒷부분에)</li>
  <li>
\[P(x_1, \cdots, x_n) = \frac{1}{Z} \prod_{c\in C}\psi_c(x_c)\]
  </li>
  <li>clique을 이용하여 UG의 확률분포를 표현할 수 있는데, maximal clique만 사용할 수도 있고, 모든 clique을 다 사용할 수도 있다.
    <ul>
      <li>
\[P(x_1, x_2, x_3, x_4) = 
\frac{1}{Z} \psi_{124}(\mathbf{x}_{124}) \psi_{234}(\mathbf{x}_{234})\]
      </li>
      <li>만약 3개 clique만을 사용한다면 변수 2개 사이 관계는 못 보지 않을까?</li>
      <li>즉 확률 분포를 어떤 clique들의 조합으로 보는지 또한 모델링 과정 중 하나일 듯.</li>
    </ul>
  </li>
</ul>

<h2 id="interpretation-of-clique-potentials">Interpretation of clique potentials</h2>
<p>X-Y-Z 라는 모델은 X와 Z의 Y에 대한 조건부 확률을 의미한다: \(X \mathrel{\unicode{x2AEB}} Z \vert Y\) (일단 지금 단계에서는 받아들이자.) 확률 분포는 아래와 같이 주어져야 한다.</p>

\[p(x,y,z) = p(y) p(x \vert y) p(z \vert y)\]

<p>또한 위에서 살펴본 것처럼, 확률 분포는 potential functions의 곱으로 표현된다.</p>

\[p(x,y,z) = \psi_{xy} \psi_{yz}\]

<p>그렇다면 여기서 potential function의 의미는?</p>
<ul>
  <li>\(p(x,y,z) = p(x,y) p(z \vert y)\) 혹은 \(p(x,y,z) = p(z,y) p(x \vert y)\)로도 표현할 수 있지만, 그렇게 되면 각각의 potential은 marginalize 혹은 conditionalize 될 수 없다. (?)</li>
  <li>따라서 potential function을 확률로서 생각하지 말고, 그 값이 높으면 확률이 높으므로 서로 연결된 값이 얼마나 그럴듯한 값들을 가지고 있는지 정도로 생각하자.</li>
</ul>

<h2 id="clique-potentials-in-exponential-form">Clique Potentials in Exponential Form</h2>
<p>clique potential이 항상 양수가 되게끔 하는 것이 불편한 경우가 있다. 예를 들어 분자의 극성을 표현할 때는 +/-로 표현하는 것이 편하겠지. 그렇기 때문에 실수 범위에서 정의되는 함수를 하나 생각하고 그 함수에 expotential 함수를 취해 양수 범위로 mapping하자.</p>

\[\psi_c(x_c) = \exp\{ -\phi_c(x_c) \}\]

<p>그렇게 되면 확률 분포는 Gibbs distribution을 따르게 된다.</p>

\[p(x) = 
\frac{1}{Z} \prod_{c\in C} \psi_c(x_c) = 
\frac{1}{Z} \exp\left( -\sum_{c\in C} \phi_c(x_c) \right)\]

<h1 id="왜-clique를-이용하여-확률-분포를-생각하는가">왜 clique를 이용하여 확률 분포를 생각하는가?</h1>]]></content><author><name>bear11235</name></author><category term="study" /><category term="machine learning" /><category term="study" /><category term="machine learning" /><category term="graph model" /><category term="bayesian network" /><category term="UG" /><category term="DAG" /><summary type="html"><![CDATA[Directed vs Undirected 적용하고자 하는 application에서 변수 간 order가 있을 수도 있고 없을 수도 있음. 오늘의 날씨와 내일의 날씨는 order가 있음. 이미지의 픽셀 정보는 order가 없음. 순서가 있는 경우에는 DAG 모델을 주로 사용하고, 순서가 없는 경우에는 Undirected Graphical Model(UG, UGM) 혹은 Markov Random Fields(MRF)를 사용한다. BN에서는 Conditional Probability Table(CPT)를 사용하여 변수 간 관계를 정했다면, UG에서는 각 변수 노드간 연결이 “얼마나 잘 어울리는가”, “그럴듯한 조합이다”의 정도를 판단한다. (?)]]></summary></entry><entry><title type="html">Query an Ansys license status</title><link href="http://localhost:4000/linux/ansys/query-ansys-license/" rel="alternate" type="text/html" title="Query an Ansys license status" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/linux/ansys/query-ansys-license</id><content type="html" xml:base="http://localhost:4000/linux/ansys/query-ansys-license/"><![CDATA[<h1 id="problem">problem</h1>
<ul>
  <li>ANSYS client host에서 server host로 license status 요청하기</li>
</ul>

<h1 id="solution">Solution</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">lmutil lmstat -c PORT@SERVER -a</code></li>
  <li>
    <p>모든 프로그램에 대한 현재 라이센스 상태를 보여준다.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@master ~]<span class="nv">$ </span>/nopt/ansys_inc/v202/licensingclient/linx64/lmutil lmstat <span class="nt">-c</span> 1055@license.tml <span class="nt">-a</span>

lmutil - Copyright <span class="o">(</span>c<span class="o">)</span> 1989-2015 Flexera Software LLC. All Rights Reserved.
Flexible License Manager status on Sun 4/16/2023 14:03

License server status: 1055@license.tml
    License file<span class="o">(</span>s<span class="o">)</span> on license.tml: /ansys_inc/shared_files/licensing/license_files/ansyslmd.lic:

license.tml: license server UP <span class="o">(</span>MASTER<span class="o">)</span> v11.19.0

Vendor daemon status <span class="o">(</span>on license.tml<span class="o">)</span>:

ansyslmd: UP v11.19.0
Feature usage info:

Users of anshpc:  <span class="o">(</span>Total of 1080 licenses issued<span class="p">;</span>  Total of 124 licenses <span class="k">in </span>use<span class="o">)</span>

<span class="s2">"anshpc"</span> v2020.0514, vendor: ansyslmd, expiry: 1-jan-0
floating license

    shlee t009 t009.tml 60048 <span class="o">(</span>v2020.0507<span class="o">)</span> <span class="o">(</span>license.tml/1055 1404<span class="o">)</span>, start Sun 4/16 14:02, 124 licenses

Users of 1spacdes:  <span class="o">(</span>Total of 26 licenses issued<span class="p">;</span>  Total of 0 licenses <span class="k">in </span>use<span class="o">)</span>

Users of cfd_base:  <span class="o">(</span>Total of 25 licenses issued<span class="p">;</span>  Total of 1 license <span class="k">in </span>use<span class="o">)</span>

<span class="s2">"cfd_base"</span> v2020.0514, vendor: ansyslmd, expiry: 1-jan-0
floating license

    shlee t009 t009.tml 60048 <span class="o">(</span>v2020.0507<span class="o">)</span> <span class="o">(</span>license.tml/1055 1304<span class="o">)</span>, start Sun 4/16 14:02

...
</code></pre></div>    </div>
  </li>
  <li>현재 사용중인 license만 출력하기 위해 별도의 shell script 작성</li>
  <li>사용중인 라이센스에 대해 USER, HOST, Start Time, (USED, AVAILABLE, TOTAL) 출력</li>
  <li>HPC의 경우, 해당 작업이 사용중인 license 개수도 출력
    <ol>
      <li><code class="language-plaintext highlighter-rouge">lmutil lmstat -c PORT@SERVER -a</code>: 전체 license status를 출력한다.</li>
      <li><code class="language-plaintext highlighter-rouge">sed '/Total of 0 licenses in use/d'</code>: 사용중인 license 개수가 0인 프로그램 문장은 지운다.</li>
      <li><code class="language-plaintext highlighter-rouge">sed '/^[[:space:]]*$/d'</code>: 빈 문장 지운다.</li>
      <li><code class="language-plaintext highlighter-rouge">awk '!/floating/' | awk '!/expiry/' </code>: license 사용중인 프로그램의 경우 ‘floating’과 ‘expiry’란 단어가 들어간 문장이 등장하는데 필요 없으므로 지운다.</li>
      <li><code class="language-plaintext highlighter-rouge">sed -e '1,8d'</code>: 앞에 필요없는 문장 지운다.</li>
      <li><code class="language-plaintext highlighter-rouge">$INDEX, $PROGRAMS</code>: For loop을 돌릴 때 필요한 변수. For loop을 돌면서 사용중인 프로그램에 대해서 각각 USER, Host 등 필요한 정보를 양식에 맞춰 기록한다.</li>
      <li><code class="language-plaintext highlighter-rouge">USER</code>, <code class="language-plaintext highlighter-rouge">HOST</code>, <code class="language-plaintext highlighter-rouge">DATE</code> 등 필요한 정보를 <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">printf</code> 등의 command를 통해 양식에 맞도록 출력한다.</li>
      <li>임시 파일을 지우면서 마무리한다.</li>
    </ol>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@master bin]# <span class="nb">cat </span>query_license_ansys.sh 
<span class="c">#!/bin/bash</span>
<span class="nb">echo</span> <span class="s2">""</span>
<span class="nb">echo</span> <span class="s2">"Only licenses being used now are shown."</span>
<span class="nb">echo</span> <span class="s2">""</span>

<span class="nv">FILE</span><span class="o">=</span><span class="nv">$HOME</span>/.license_status_ansys.tmp

/nopt/ansys_inc/v202/licensingclient/linx64/lmutil lmstat <span class="nt">-c</span> 1055@license.tml <span class="nt">-a</span> |<span class="se">\</span>
<span class="nb">sed</span> <span class="s1">'/Total of 0 licenses in use/d'</span> |<span class="se">\</span>
<span class="nb">sed</span> <span class="s1">'/^[[:space:]]*$/d'</span> |<span class="se">\</span>
<span class="nb">awk</span> <span class="s1">'!/floating/'</span> | <span class="nb">awk</span> <span class="s1">'!/expiry/'</span> |<span class="se">\</span>
<span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'1,8d'</span> <span class="o">&gt;</span> <span class="nv">$FILE</span>

<span class="nv">INDEX</span><span class="o">=(</span><span class="si">$(</span><span class="nb">cat</span> <span class="nv">$FILE</span> | <span class="nb">nl</span> | <span class="nb">grep</span> <span class="s2">"Users of"</span> | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="si">)</span> <span class="k">$((</span> <span class="sb">`</span><span class="o">(</span><span class="nb">cat</span> <span class="nv">$FILE</span> | <span class="nb">nl</span> | <span class="nb">tail</span> <span class="nt">-1</span> | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="o">)</span><span class="sb">`</span> <span class="o">+</span> <span class="m">1</span> <span class="k">))</span> <span class="o">)</span>
<span class="nv">PROGRAMS</span><span class="o">=(</span><span class="si">$(</span><span class="nb">cat</span> <span class="nv">$FILE</span> | <span class="nb">grep</span> <span class="s2">"Users of"</span> | <span class="nb">awk</span> <span class="s1">'{print $3}'</span> | <span class="nb">sed</span> <span class="s1">'s/://g'</span><span class="si">)</span><span class="o">)</span>

<span class="k">for </span>idx <span class="k">in</span> <span class="sb">`</span><span class="nb">seq </span>0 <span class="k">$((</span> <span class="k">${#</span><span class="nv">PROGRAMS</span><span class="p">[@]</span><span class="k">}</span> <span class="o">-</span><span class="m">1</span> <span class="k">))</span><span class="sb">`</span>
<span class="k">do
    </span><span class="nv">i</span><span class="o">=</span><span class="k">${</span><span class="nv">INDEX</span><span class="p">[</span><span class="nv">$idx</span><span class="p">]</span><span class="k">}</span>
    <span class="nv">j</span><span class="o">=</span><span class="k">${</span><span class="nv">INDEX</span><span class="p">[</span><span class="k">$((</span> <span class="nv">$idx</span> <span class="o">+</span> <span class="m">1</span> <span class="k">))</span><span class="p">]</span><span class="k">}</span>
    <span class="nv">PROGRAM</span><span class="o">=</span><span class="k">${</span><span class="nv">PROGRAMS</span><span class="p">[</span><span class="nv">$idx</span><span class="p">]</span><span class="k">}</span>
    <span class="nv">TOT</span><span class="o">=</span><span class="si">$(</span><span class="nb">head</span> -<span class="nv">$i</span> <span class="nv">$FILE</span> | <span class="nb">tail</span> <span class="nt">-n</span> +<span class="nv">$i</span> | <span class="nb">awk</span> <span class="s1">'{print $6}'</span><span class="si">)</span>
    <span class="nv">USE</span><span class="o">=</span><span class="si">$(</span><span class="nb">head</span> -<span class="nv">$i</span> <span class="nv">$FILE</span> | <span class="nb">tail</span> <span class="nt">-n</span> +<span class="nv">$i</span> | <span class="nb">awk</span> <span class="s1">'{print $11}'</span><span class="si">)</span>
    <span class="nv">AVA</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$TOT</span> <span class="o">-</span> <span class="nv">$USE</span> <span class="k">))</span>
    <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"license in used: </span><span class="k">${</span><span class="nv">PROGRAM</span><span class="k">}</span><span class="s2"> (used, available, total) = (</span><span class="k">${</span><span class="nv">USE</span><span class="k">}</span><span class="s2">, </span><span class="k">${</span><span class="nv">AVA</span><span class="k">}</span><span class="s2">, </span><span class="k">${</span><span class="nv">TOT</span><span class="k">}</span><span class="s2">)"</span>

    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$PROGRAM</span> <span class="o">==</span> <span class="s2">"anshpc"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">" --------------------------------------------- "</span>
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"|    User    |    Host    |  Start Time | Use |"</span>	
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"|---------------------------------------------|"</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">" --------------------------------------- "</span>
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"|    User    |    Host    |  Start Time |"</span>	
        <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"|---------------------------------------|"</span>
    <span class="k">fi

    for </span>k <span class="k">in</span> <span class="sb">`</span><span class="nb">seq</span> <span class="k">$((</span> <span class="nv">$i</span> <span class="o">+</span> <span class="m">1</span> <span class="k">))</span> <span class="k">$((</span> <span class="nv">$j</span> <span class="o">-</span> <span class="m">1</span> <span class="k">))</span><span class="sb">`</span>
    <span class="k">do
        </span><span class="nv">LINE</span><span class="o">=</span><span class="si">$(</span><span class="nb">head</span> -<span class="nv">$k</span> <span class="nv">$FILE</span> | <span class="nb">tail</span> <span class="nt">-n</span> +<span class="nv">$k</span><span class="si">)</span>
			
        <span class="nv">USER</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$LINE</span> | <span class="nb">awk</span> <span class="s1">'{print $1}'</span> | <span class="nb">sed</span> <span class="s1">'s/$/         /'</span> | <span class="nb">cut</span> <span class="nt">-c</span> <span class="nt">-10</span><span class="si">)</span>
        <span class="nv">COMP</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$LINE</span> | <span class="nb">awk</span> <span class="s1">'{print $2}'</span> | <span class="nb">sed</span> <span class="s1">'s/$/         /'</span> | <span class="nb">cut</span> <span class="nt">-c</span> <span class="nt">-10</span><span class="si">)</span>
        <span class="nv">DATE</span><span class="o">=</span><span class="si">$(</span><span class="nb">printf</span> <span class="s2">"%02d/%02d"</span> <span class="si">$(</span><span class="nb">echo</span> <span class="nv">$LINE</span> | <span class="nb">awk</span> <span class="s1">'{print $10}'</span> | <span class="nb">sed</span> <span class="s1">'s/\// /'</span><span class="si">))</span>
        <span class="nv">TIME</span><span class="o">=</span><span class="si">$(</span><span class="nb">printf</span> <span class="s2">"%02d:%s"</span>  <span class="si">$(</span><span class="nb">echo</span> <span class="nv">$LINE</span> | <span class="nb">awk</span> <span class="s1">'{print $11}'</span> | <span class="nb">sed</span> <span class="s1">'s/:/ /'</span> | <span class="nb">sed</span> <span class="s1">'s/,//'</span> <span class="si">))</span>
			
        <span class="k">if</span> <span class="o">[[</span> <span class="nv">$PROGRAM</span> <span class="o">==</span> <span class="s2">"anshpc"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
            </span><span class="nv">USEHPC</span><span class="o">=</span><span class="si">$(</span><span class="nb">printf</span> <span class="s2">"%3d"</span> <span class="si">$(</span><span class="nb">echo</span> <span class="nv">$LINE</span> | <span class="nb">awk</span> <span class="s1">'{print $12}'</span> <span class="si">))</span>
            <span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"| </span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2"> | </span><span class="k">${</span><span class="nv">COMP</span><span class="k">}</span><span class="s2"> | </span><span class="k">${</span><span class="nv">DATE</span><span class="k">}</span><span class="s2">-</span><span class="k">${</span><span class="nv">TIME</span><span class="k">}</span><span class="s2"> | </span><span class="k">${</span><span class="nv">USEHPC</span><span class="k">}</span><span class="s2"> |"</span>
        <span class="k">else
            </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">"| </span><span class="k">${</span><span class="nv">USER</span><span class="k">}</span><span class="s2"> | </span><span class="k">${</span><span class="nv">COMP</span><span class="k">}</span><span class="s2"> | </span><span class="k">${</span><span class="nv">DATE</span><span class="k">}</span><span class="s2">-</span><span class="k">${</span><span class="nv">TIME</span><span class="k">}</span><span class="s2"> |"</span>
        <span class="k">fi
    done

		
    if</span> <span class="o">[[</span> <span class="nv">$PROGRAM</span> <span class="o">==</span> <span class="s2">"anshpc"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">" --------------------------------------------- "</span>
    <span class="k">else
        </span><span class="nb">echo</span> <span class="nt">-e</span> <span class="s2">" --------------------------------------- "</span>
    <span class="k">fi
    </span><span class="nb">echo</span> <span class="s2">""</span>
<span class="k">done

</span><span class="nb">rm</span> <span class="nv">$FILE</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>위 script를 사용한 출력 결과는 아래와 같다.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@master ~]<span class="nv">$ </span>query_license_ansys 

Only licenses being used now are shown.

license <span class="k">in </span>used: anshpc <span class="o">(</span>used, available, total<span class="o">)</span> <span class="o">=</span> <span class="o">(</span>124, 956, 1080<span class="o">)</span>
<span class="nt">---------------------------------------------</span> 
|    User    |    Host    |  Start Time | Use |
|---------------------------------------------|
| shlee      | t009       | 04/16-14:03 | 124 |
<span class="nt">---------------------------------------------</span> 

license <span class="k">in </span>used: cfd_base <span class="o">(</span>used, available, total<span class="o">)</span> <span class="o">=</span> <span class="o">(</span>1, 24, 25<span class="o">)</span>
<span class="nt">---------------------------------------</span> 
|    User    |    Host    |  Start Time |
|---------------------------------------|
| shlee      | t009       | 04/16-14:03 |
<span class="nt">---------------------------------------</span> 

license <span class="k">in </span>used: cfd_solve_level1 <span class="o">(</span>used, available, total<span class="o">)</span> <span class="o">=</span> <span class="o">(</span>1, 24, 25<span class="o">)</span>
<span class="nt">---------------------------------------</span> 
|    User    |    Host    |  Start Time |
|---------------------------------------|
| shlee      | t009       | 04/16-14:03 |
<span class="nt">---------------------------------------</span> 

license <span class="k">in </span>used: cfd_solve_level2 <span class="o">(</span>used, available, total<span class="o">)</span> <span class="o">=</span> <span class="o">(</span>1, 24, 25<span class="o">)</span>
<span class="nt">---------------------------------------</span> 
|    User    |    Host    |  Start Time |
|---------------------------------------|
| shlee      | t009       | 04/16-14:03 |
<span class="nt">---------------------------------------</span> 

</code></pre></div>    </div>
  </li>
</ul>

<h1 id="command">Command</h1>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">awk</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">sed</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">For</code></p>
  </li>
</ol>]]></content><author><name>bear11235</name></author><category term="linux" /><category term="ansys" /><category term="linux" /><category term="ansys" /><category term="license" /><summary type="html"><![CDATA[problem ANSYS client host에서 server host로 license status 요청하기]]></summary></entry><entry><title type="html">Query a TecPlot license status</title><link href="http://localhost:4000/linux/tecplot/query-tecplot-license/" rel="alternate" type="text/html" title="Query a TecPlot license status" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/linux/tecplot/query-tecplot-license</id><content type="html" xml:base="http://localhost:4000/linux/tecplot/query-tecplot-license/"><![CDATA[<h1 id="problem">problem</h1>
<ul>
  <li>TecPlot client host에서 server host로 license status 요청하기</li>
</ul>

<h1 id="solution">Solution</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rlmutil rlmstat -c PORT@SERVER</code>
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@master bin]# /opt/tecplot/360ex_2022r2/bin/rlmutil rlmstat <span class="nt">-a</span> <span class="nt">-c</span> 27100@license.tml
Setting license file path to 27100@license.tml
rlmutil v12.4
Copyright <span class="o">(</span>C<span class="o">)</span> 2006-2018, Reprise Software, Inc. All rights reserved.


rlm status on license.tml <span class="o">(</span>port 27100<span class="o">)</span>, up 00:28:24
rlm software version v12.4 <span class="o">(</span>build:2<span class="o">)</span>
rlm <span class="nb">comm </span>version: v1.2
Startup <span class="nb">time</span>: Sun Apr 16 13:06:01 2023
Todays Statistics <span class="o">(</span>00:28:23<span class="o">)</span>, init <span class="nb">time</span>: Sun Apr 16 13:06:02 2023
Recent Statistics <span class="o">(</span>00:28:23<span class="o">)</span>, init <span class="nb">time</span>: Sun Apr 16 13:06:02 2023

             Recent Stats         Todays Stats         Total Stats
              00:28:23             00:28:23             00:28:24
Messages:    71 <span class="o">(</span>0/sec<span class="o">)</span>           71 <span class="o">(</span>0/sec<span class="o">)</span>          71 <span class="o">(</span>0/sec<span class="o">)</span>
Connections: 52 <span class="o">(</span>0/sec<span class="o">)</span>           52 <span class="o">(</span>0/sec<span class="o">)</span>          52 <span class="o">(</span>0/sec<span class="o">)</span>

<span class="nt">---------</span> ISV servers <span class="nt">----------</span>
   Name           Port Running Restarts
teclmd           27101   Yes      2

<span class="nt">------------------------</span>

teclmd ISV server status on license.tml <span class="o">(</span>port 27101<span class="o">)</span>, up 00:03:37
teclmd software version v12.4 <span class="o">(</span>build: 2<span class="o">)</span>
teclmd <span class="nb">comm </span>version: v1.2
teclmd Debug log filename: +./teclmd.log
teclmd Report log filename: ./report.log
Startup <span class="nb">time</span>: Sun Apr 16 13:30:48 2023
Todays Statistics <span class="o">(</span>00:03:37<span class="o">)</span>, init <span class="nb">time</span>: Sun Apr 16 13:30:48 2023
Recent Statistics <span class="o">(</span>00:03:37<span class="o">)</span>, init <span class="nb">time</span>: Sun Apr 16 13:30:48 2023

             Recent Stats         Todays Stats         Total Stats
              00:03:37             00:03:37             00:03:37
Messages:    37 <span class="o">(</span>0/sec<span class="o">)</span>           37 <span class="o">(</span>0/sec<span class="o">)</span>          37 <span class="o">(</span>0/sec<span class="o">)</span>
Connections: 17 <span class="o">(</span>0/sec<span class="o">)</span>           17 <span class="o">(</span>0/sec<span class="o">)</span>          17 <span class="o">(</span>0/sec<span class="o">)</span>
Checkouts:   1 <span class="o">(</span>0/sec<span class="o">)</span>           1 <span class="o">(</span>0/sec<span class="o">)</span>          1 <span class="o">(</span>0/sec<span class="o">)</span>
Denials:     1 <span class="o">(</span>0/sec<span class="o">)</span>           1 <span class="o">(</span>0/sec<span class="o">)</span>          1 <span class="o">(</span>0/sec<span class="o">)</span>
Removals:    0 <span class="o">(</span>0/sec<span class="o">)</span>           0 <span class="o">(</span>0/sec<span class="o">)</span>          0 <span class="o">(</span>0/sec<span class="o">)</span>


<span class="nt">------------------------</span>

teclmd license pool status on license.tml <span class="o">(</span>port 27101<span class="o">)</span>

360ex v2024.04
    count: 1, <span class="c"># reservations: 0, inuse: 0, exp: 30-apr-2024</span>
    obsolete: 0, min_remove: 120, total checkouts: 1
rs v2024.04
    count: 1, <span class="c"># reservations: 0, inuse: 0, exp: 30-apr-2024</span>
    obsolete: 0, min_remove: 120, total checkouts: 0
chorus v2024.04
    count: 1, <span class="c"># reservations: 0, inuse: 0, exp: 30-apr-2024</span>
    obsolete: 0, min_remove: 120, total checkouts: 0
batch v2024.04
    count: 1, <span class="c"># reservations: 0, inuse: 0, exp: 30-apr-2024</span>
    obsolete: 0, min_remove: 120, total checkouts: 0
fv v2024.04
    count: 1, <span class="c"># reservations: 0, inuse: 0, exp: 30-apr-2024</span>
    obsolete: 0, min_remove: 120, total checkouts: 0
360 v2013.1
    Token-based license
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="issues">Issues</h1>
<ul>
  <li><code class="language-plaintext highlighter-rouge">rlmutil</code> 도움말을 보면 아래와 같이 나오는데, 문제는 일반 사용자도 rlmdown, rlmreread 같은 명령어를 사용하여 lisence server에 명령을 내릴 수 있다는 것.
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>root@master bin]# /opt/tecplot/360ex_2022r2/bin/rlmutil <span class="nt">-h</span>
Usage: rlmutil program &lt;args&gt;, <span class="nt">-OR-</span>
          program &lt;args&gt;
 where program is one of:
 	rlmdebug   rlmdown    rlmhostid
 	rlmnewlog  rlmremove  rlmreread
 	rlmstat    rlmswitch  rlmswitchr
 args are:
 <span class="nt">-c</span> license_file | port@host - to specify license
 <span class="nt">-dat</span> - use <span class="k">*</span>.dat instead of <span class="k">*</span>.lic <span class="k">for </span>license file
 <span class="nt">-h</span> - print usage information and <span class="nb">exit</span>
 <span class="nt">-q</span> - don<span class="s1">'t prompt on rlmdown/rlmremove/rlmswitch(r)
  and don'</span>t check license checksums
 <span class="nt">-v</span> - print version and <span class="nb">exit</span>
 <span class="nt">-z</span> password - specify license password
  rlmdebug <span class="o">[</span>product]
  rlmdown <span class="o">[</span>isv] <span class="o">[</span>RLM]
  rlmhostid <span class="nt">-q</span> <span class="o">[[</span>-]32|disksn|ether|gc|ip|internet|host|user|rlmid1]
  rlmnewlog isv log-file-name
  rlmremove server_host port isv handle
  rlmreread <span class="o">[</span>isv]
  rlmstat <span class="o">[</span><span class="nt">-a</span><span class="o">]</span> <span class="o">[</span><span class="nt">-i</span> <span class="o">[</span>isv]] <span class="nt">-I</span> <span class="o">[</span><span class="nt">-l</span> <span class="o">[</span>isv]] <span class="o">[</span><span class="nt">-n</span> <span class="o">[</span>node]] <span class="o">[</span><span class="nt">-p</span> <span class="o">[</span>product]] <span class="o">[</span><span class="nt">-u</span> <span class="o">[</span>user]] 
  rlmstat <span class="nt">-avail</span> <span class="o">[</span><span class="nt">-b</span><span class="o">]</span> <span class="o">[</span><span class="nt">-i</span> isv] <span class="o">[</span><span class="nt">-p</span> product]
  rlmswitch isv new-file
  rlmswitchr isv new-file
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name>bear11235</name></author><category term="linux" /><category term="tecplot" /><category term="linux" /><category term="tecplot" /><category term="license" /><summary type="html"><![CDATA[problem TecPlot client host에서 server host로 license status 요청하기]]></summary></entry><entry><title type="html">Bayesian Network 공부하기</title><link href="http://localhost:4000/study/machine%20learning/bayesian-network/" rel="alternate" type="text/html" title="Bayesian Network 공부하기" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/study/machine%20learning/bayesian-network</id><content type="html" xml:base="http://localhost:4000/study/machine%20learning/bayesian-network/"><![CDATA[<h1 id="bayesian-networkbn-란">Bayesian Network(BN) 란?</h1>
<ul>
  <li><strong>Bayesian Network</strong> = <strong>Graph</strong> + <strong>Conditional Probability Table</strong></li>
  <li>확률 변수 사이의 상관관계를 그래프로 표현하고, 변수 사이의 조건부 확률 분포를 학습</li>
  <li>그래프는 node와 edge로 표현된다. BN은 확률 변수를 node로, 확률 변수 사이 직접적인 의존성(direct dependency)을 edge로 표현한다.</li>
  <li>BN에서 사용하는 그래프 모델은 Directed Acyclic Graph (DAG), 즉 비순환-방향성 그래프로 표현된다.
    <ul>
      <li>Directed: 노드 간 연결은 단순 선분이 아니라 방향성이 있는 화살표로 표현된다.</li>
      <li>Acyclic: a-&gt;b-&gt;c-&gt;a 와 같이 순환적인 구조가 없다.</li>
    </ul>
  </li>
</ul>

<p><img src="/assets/images/posts/MLDL/bayesian-network-01.png" alt="" /></p>]]></content><author><name>bear11235</name></author><category term="study" /><category term="machine learning" /><category term="study" /><category term="machine learning" /><category term="bayesian network" /><summary type="html"><![CDATA[Bayesian Network(BN) 란? Bayesian Network = Graph + Conditional Probability Table 확률 변수 사이의 상관관계를 그래프로 표현하고, 변수 사이의 조건부 확률 분포를 학습 그래프는 node와 edge로 표현된다. BN은 확률 변수를 node로, 확률 변수 사이 직접적인 의존성(direct dependency)을 edge로 표현한다. BN에서 사용하는 그래프 모델은 Directed Acyclic Graph (DAG), 즉 비순환-방향성 그래프로 표현된다. Directed: 노드 간 연결은 단순 선분이 아니라 방향성이 있는 화살표로 표현된다. Acyclic: a-&gt;b-&gt;c-&gt;a 와 같이 순환적인 구조가 없다.]]></summary></entry><entry><title type="html">Hidden Markov Model 공부하기</title><link href="http://localhost:4000/study/machine%20learning/hidden-markov-model/" rel="alternate" type="text/html" title="Hidden Markov Model 공부하기" /><published>2023-04-16T00:00:00+09:00</published><updated>2023-04-16T00:00:00+09:00</updated><id>http://localhost:4000/study/machine%20learning/hidden-markov-model</id><content type="html" xml:base="http://localhost:4000/study/machine%20learning/hidden-markov-model/"><![CDATA[<h1 id="markov-chain">Markov Chain</h1>

<h2 id="markov-property">Markov Property</h2>
<ul>
  <li>Markov 성질은 현재 시점의 상태는 바로 직전 시점의 상태에만 의존한다는 것이다.</li>
  <li>즉 $ P(X_{n} \vert X_{n-1}, X_{n-2}, \cdots, X_{1}) = P(X_{n} \vert X_{n-1}) $</li>
  <li>이것은 다가오는 미래는 과거에 영향 받지 않고 온전히 현재 상태에만 의존함을 의미한다.</li>
</ul>

<h2 id="definition">Definition</h2>
<ul>
  <li>A Markov process is a stochastic process that satisfies the Markov property (sometimes characterized as “memorylessness”). In simpler terms, it is a process for which predictions can be made regarding future outcomes based solely on its present state and—most importantly—such predictions are just as good as the ones that could be made knowing the process’s full history. In other words, conditional on the present state of the system, its future and past states are independent.</li>
  <li>Markov chain은 Markov 성질을 만족하는 확률 과정이다. 쉽게 말해,, 한 상태에서 다른 상태로 상태가 전이될 때의 확률이 Markov property를 만족하는 chain을 의미한다. 다른 상태로 전이할 때 이전 상태의 history는 전혀 중요하지 않고 현재 상태만 고려하면 된다.</li>
  <li>예를 들어, 날씨의 변화를 Markov chain을 통해 표현한다는 것은 오늘의 날씨는 바로 전날의 날씨에만 영향을 받으며, 또한 내일의 날씨는 오늘의 날씨에만 영향을 받는다는 것을 의미한다. 굉장히 강력한 가정이라 볼 수 있다.</li>
</ul>

<h2 id="transition-matrix">Transition Matrix</h2>
<ul>
  <li>n개의 상태 $(X_{1}, \cdot, X_{n})$ 로 구성된 Markov chain을 생각해보자.</li>
  <li>$i$번째 상태 $X_{i}$에서 $j$번째 상태 $X_{j}$로 전이될 확률을 $P_{ij}$로 생각할 수 있다.</li>
  <li>Transition Matrix $P$는 $P_{ij}$를 성분으로 갖는 $n \times n$ 크기의 행렬이다.</li>
</ul>

<h1 id="hidden-markov-model-hmm">Hidden Markov Model (HMM)</h1>

<h2 id="definition-1">Definition</h2>
<ul>
  <li>A hidden Markov model (HMM) is a statistical Markov model in which the system being modeled is assumed to be a Markov process with unobservable (“hidden”) states.</li>
  <li>관측가능한 변수 $(X)$와 관측이 불가능한 은닉 상태 $(Z)$로 이루어진 Markov 시스템을 의미한다.</li>
  <li>우리가 관측하는 변수들끼리는 markov 성질을 만족하지 않지만, 그것들을 야기하는 은닉 상태는 markov chain을 이룬다.</li>
  <li>HMM의 Joint Probability Distribution $P(X_1, \cdots, X_n, Z_1, \cdots, Z_n)$를 그래프로 표현하면 아래와 같이 표현할 수 있다. <br />
<img src="/assets/images/posts/MLDL/hidden-markov-model/01.png" style="width:50%" /></li>
</ul>

<h2 id="example">Example</h2>
<p><strong>Part-Of-Speech(POS) Tag</strong> <br />
  <img src="/assets/images/posts/MLDL/hidden-markov-model/02.png" style="width:45%" />
  <img src="/assets/images/posts/MLDL/hidden-markov-model/03.png" style="width:45%" /></p>
<ul>
  <li>“Janet will back the bill”이란 문장이 있다고 생각해보자.</li>
  <li>여기서 우리가 관측한 변수는 Janet, will 등과 같은 단어 자체다.</li>
  <li>이때 HMM은 상태의 전이 확률(A단어 다음 B단어가 등장할 확률)을 단어와 단어 사이의 직접적인 관계가 아닌 은닉 상태 Z를 통해 표현된다고 본다.</li>
  <li>본 예시에서 은닉 상태 Z는 단어의 품사다. Janet이란 단어$(X_1)$ 뒤에 will이란 단어$(X_2)$가 등장할 확률은 각각의 품사와 함께 표현된다.</li>
  <li>$P(X_2, X_1) = P(X_1, X_2, Z_1, Z_2) = P(Z_1)P(X_1 \vert Z_1)P(Z_2 \vert Z_1)P(X_2 \vert Z_2)$
    <ul>
      <li>$P(Z_1)$: $Z_1$(명사)의 품사가 등장할 확률</li>
      <li>$P(X_1 \vert Z_1)$: 품사가 $Z_1$(명사)일 때, 단어가 $X_1$(Janet)일 확률</li>
      <li>$P(Z_2 \vert Z_1)$: 이전 품사가 $Z_1$(명사)일 때, 다음 품사가 $Z_2$(조동사)일 확률</li>
      <li>$P(X_2 \vert Z_2)$: 품사가 $Z_2$(조동사)일 때, 단어가 $X_2$(will)일 확률</li>
    </ul>
  </li>
</ul>

<h2 id="hmm">HMM</h2>
<p><img src="/assets/images/posts/MLDL/hidden-markov-model/01.png" style="width:70%" /> <br />
위 그림과 같은 Hidden Markov Model를 생각해보자. 이때 편의를 위해 HMM이 다음의 조건을 만족한다 가정하자.</p>
<ul>
  <li>각각의 은닉 상태는 \(\{ 1, \cdots, m \}\) 중 하나를 갖는다: \(Z_i \in \{1, \cdots, m\}\)</li>
  <li>초기 분포를 $\pi$라고 하자: $\pi_i = P(Z_1=i)$</li>
  <li>Time-homogeneity를 만족한다. 전이확률 $T_{ij}=P(Z_{t+1}=j \vert Z_t=i)$이 time-index인 t에 대해 변하지 않는다. 즉 전이 확률은 시간에 대해 independent하다.</li>
  <li>마찬가지로 emission distribution $\epsilon_{i}(x_t)=P(x_{t} \vert Z_{t}=i)$ 또한 time-independent하다.</li>
</ul>

<h2 id="tasks-in-hmm">Tasks in HMM</h2>
<p><strong>1. Decoding</strong></p>
<ul>
  <li>Find $argmax_z P(z \vert x)$.</li>
  <li>Given an HMM, what is the most likely sequence of states z to generate output x?</li>
  <li>어떤 HMM에 대해 주어진 output $\mathbf{X}$를 생성해냈을 가장 그럴듯한 sequence of hidden state $\mathbf{Z}$ 가 무엇이냐?</li>
</ul>

<p><strong>2. Likelihood</strong></p>
<ul>
  <li>Compute $P(X)$</li>
  <li>Given an HMM parametrized with \(\Theta = (\pi, T, \epsilon)\), compute the likelihood of the output sequence.</li>
  <li>\(\Theta = (\pi, T, \epsilon)\)으로 parametrization 된 HMM이 주어졌을 때, output $\mathbf{X}$이 생성될 확률은?</li>
</ul>

<p><strong>3. Estimation</strong></p>
<ul>
  <li>Find $argmax_{\Theta} P(X;\Theta)$</li>
  <li>Learning</li>
  <li>Maximum Likelihood Estimation</li>
</ul>]]></content><author><name>bear11235</name></author><category term="study" /><category term="machine learning" /><category term="study" /><category term="machine learning" /><category term="markov" /><category term="bayesian network" /><summary type="html"><![CDATA[Markov Chain]]></summary></entry><entry><title type="html">Research Note</title><link href="http://localhost:4000/research/research-note/" rel="alternate" type="text/html" title="Research Note" /><published>2023-04-01T00:00:00+09:00</published><updated>2023-04-01T00:00:00+09:00</updated><id>http://localhost:4000/research/research-note</id><content type="html" xml:base="http://localhost:4000/research/research-note/"><![CDATA[<h2 id="2023-04-11-화">2023-04-11 (화)</h2>
<ul>
  <li>두 개의 난류 유동이 있을 때, 그 둘의 유사성을 어떻게 판단할 것인가?</li>
</ul>

<h2 id="2023-04-13-목">2023-04-13 (목)</h2>
<ul>
  <li>난류 유동의 순간적인(?) time scale은 어떻게 구할 것인가?
    <ul>
      <li></li>
    </ul>
  </li>
</ul>]]></content><author><name>bear11235</name></author><category term="research" /><summary type="html"><![CDATA[2023-04-11 (화) 두 개의 난류 유동이 있을 때, 그 둘의 유사성을 어떻게 판단할 것인가?]]></summary></entry></feed>